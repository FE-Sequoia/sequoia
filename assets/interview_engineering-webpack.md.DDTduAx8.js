import{_ as e,c as a,o as i,ag as l}from"./chunks/framework.CSzp38HB.js";const n="/sequoia/assets/2506181.BHXVjkvP.png",u=JSON.parse('{"title":"前端工程化","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"interview/engineering-webpack.md","filePath":"interview/engineering-webpack.md","lastUpdated":1750232948000}'),t={name:"interview/engineering-webpack.md"};function p(o,s,d,c,r,h){return i(),a("div",null,s[0]||(s[0]=[l(`<h1 id="前端工程化" tabindex="-1">前端工程化 <a class="header-anchor" href="#前端工程化" aria-label="Permalink to &quot;前端工程化&quot;">​</a></h1><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Webpack/Vite 打包原理、Loader/Plugin 编写</span></span>
<span class="line"><span></span></span>
<span class="line"><span>NPM、模块化（CommonJS vs ESModule）</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Babel 转译原理</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Git 多人协作流程</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="webpack" tabindex="-1">webpack <a class="header-anchor" href="#webpack" aria-label="Permalink to &quot;webpack&quot;">​</a></h2><h2 id="_1-概念速览" tabindex="-1">1.概念速览 <a class="header-anchor" href="#_1-概念速览" aria-label="Permalink to &quot;1.概念速览&quot;">​</a></h2><p><code>Webpack</code>是<code>JavaScript</code>应用程序的静态模块打包工具，会递归创建一个依赖关系图，其中包含应该程序需要的模块，然后将这些模块打包成一个或多个<code>Bundle</code>。</p><p><code>Webpack</code> 最核心的功能是将各种类型的资源，包括图片、CSS、JS等，转译、组合、拼接、生成JS格式等Bundler文件。</p><div align="center"><img src="`+n+`" width="680" alt="webpack 流程图" align="center"></div><p>这个过程核心完成了 <strong>内容转换 + 资源合并</strong> 两种功能，实现上包含三个阶段：</p><ol><li>初始化阶段 <ol><li><strong>初始化参数</strong>：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数</li><li><strong>创建编译器对象</strong>：用上一步得到的参数创建 <code>Compiler</code> 对象</li><li><strong>初始化编译环境</strong>：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等</li><li><strong>开始编译</strong>：执行 <code>compiler</code> 对象的 <code>run</code> 方法</li><li><strong>确定入口</strong>：根据配置中的 <code>entry</code> 找出所有的入口文件，调用 <code>compilition.addEntry</code> 将入口文件转换为 <code>dependence</code> 对象</li></ol></li><li>构建阶段 <ol><li><strong>编译模块(make)</strong>：根据 <code>entry</code> 对应的 <code>dependence</code> 创建 <code>module</code> 对象，调用 <code>loader</code> 将模块转译为标准 JS 内容，调用 JS 解释器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 递归 本步骤直到所有入口依赖的文件都经过了本步骤的处理</li><li><strong>完成模块编译</strong>：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的 <strong>依赖关系图</strong></li></ol></li><li>生成阶段 <ol><li><strong>输出资源(seal)</strong>：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>Chunk</code>，再把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会</li><li><strong>写入文件系统(emitAssets)</strong>：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统</li></ol></li></ol><h3 id="_1-1-一些名词" tabindex="-1">1.1 一些名词 <a class="header-anchor" href="#_1-1-一些名词" aria-label="Permalink to &quot;1.1 一些名词&quot;">​</a></h3><ol><li><code>Entry</code>：编译入口，webpack 编译的起点</li><li><code>Compiler</code>：编译管理器，webpack 启动后会创建 <code>compiler</code> 对象，该对象一直存活直到结束退出</li><li><code>Compilation</code>：单次编辑过程的管理器，比如 <code>watch = true</code> 时，运行过程中只有一个 <code>compiler</code> 但每次文件变更触发重新编译时，都会创建一个新的 <code>compilation</code> 对象</li><li><code>Dependence</code>：依赖对象，webpack 基于该类型记录模块间依赖关系</li><li><code>Module</code>：webpack 内部所有资源都会以“module”对象形式存在，所有关于资源的操作、转译、合并都是以 “module” 为基本单位进行的</li><li><code>Chunk</code>：编译完成准备输出时，webpack 会将 <code>module</code> 按特定的规则组织成一个一个的 <code>chunk</code>，这些 <code>chunk</code> 某种程度上跟最终输出一一对应</li><li><code>Loader</code>：资源内容转换器，其实就是实现从内容 A 转换 B 的转换器</li><li><code>Plugin</code>：webpack构建过程中，会在特定的时机广播对应的事件，插件监听这些事件，在特定时间点介入编译过程</li></ol><h2 id="_2-打包流程" tabindex="-1">2. 打包流程 <a class="header-anchor" href="#_2-打包流程" aria-label="Permalink to &quot;2. 打包流程&quot;">​</a></h2><ul><li>初始化参数。获取用户在webpack.config.js文件配置的参数</li><li>开始编译。初始化compiler对象，注册所有的插件plugins，插件开始监听webpack构建过程的生命周期事件，不同环节会有相应的处理，然后开始执行编译</li><li>确定入口。根据webpack.config.js文件的entry入口，开始解析文件构建ast语法树，找寻依赖，递归下去</li><li>编译模块。递归过程中，根据文件类型和loader配置，调用相应的loader对不同的文件做转换处理，在找出该模块依赖的模块，递归本操作，直到项目中依赖的所有模块都经过了本操作的编译处理</li><li>完成编译并输出。递归结束，得到每个文件结果，包含转换后的模块以及他们之前的依赖关系，根据entry以及output等配置生成代码块chunk</li><li>打包完成。根据output输出所有的chunk到相应的文件目录</li></ul><h2 id="_3-loader-和-plugin-是什么-区别是什么" tabindex="-1">3. Loader 和 Plugin 是什么？区别是什么？ <a class="header-anchor" href="#_3-loader-和-plugin-是什么-区别是什么" aria-label="Permalink to &quot;3. Loader 和 Plugin 是什么？区别是什么？&quot;">​</a></h2><h3 id="loader是什么" tabindex="-1">Loader是什么？ <a class="header-anchor" href="#loader是什么" aria-label="Permalink to &quot;Loader是什么？&quot;">​</a></h3><p><code>Loader</code>让<code>Webpack</code>去处理那些非JavaScript文件(webpack自身只理解javascript)。loader可以将所有类型的文件转换成webpack能处理的有效模块。然后利用webpack的打包能力，对它们进行处 理。</p><h3 id="plugin-是什么" tabindex="-1">Plugin 是什么？ <a class="header-anchor" href="#plugin-是什么" aria-label="Permalink to &quot;Plugin 是什么？&quot;">​</a></h3><p>插件可以用于执行其他范围更广的任务，插件的范围包括，打包优化，代码压缩，甚至可以重新定义环境中的变量。插件的目的是用于解决loader无法实现的其他事。</p><h3 id="_3-1-以-vue文件为例-vue-loader-在构建过程中做了什么" tabindex="-1">3. 1 以<code>.vue</code>文件为例，<code>vue-loader</code> 在构建过程中做了什么？ <a class="header-anchor" href="#_3-1-以-vue文件为例-vue-loader-在构建过程中做了什么" aria-label="Permalink to &quot;3. 1 以\`.vue\`文件为例，\`vue-loader\` 在构建过程中做了什么？&quot;">​</a></h3><p>以一个典型的 <code>.vue</code> 文件为例</p><div class="language-vue vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ message }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">		data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				message: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Hello, Vue!&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> scoped</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">	div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>vue-loader</code> 在构建过程中主要做了以下几件事</p><ol><li>将<code>.vue</code>文件解析成三个部分：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>。这样一来，才能够让 Webpack的其他加载器和插件能够处理。</li><li>处理<code>&lt;template&gt;</code>，<code>vue-loader</code> 会将 <code>&lt;template&gt;</code> 部分传递给 <code>vue-template-compiler</code> 进行编译，将 Vue 的模板语法编译为可执行的渲染函数。</li><li>处理<code>&lt;script&gt;</code>部分，<code>&lt;script&gt;</code> 部分通常包含 Vue 组件的逻辑，<code>vue-loader</code> 会将其作为普通的 JavaScript 模块处理。它会使用 <code>babel-loader</code> 或其他 JavaScript 加载器对 <code>&lt;script&gt;</code> 中的代码进行转译，将 ES6 及以上的代码转换为浏览器可识别的代码，确保代码可以在不同的浏览器环境中运行。</li><li>处理 <code>&lt;style&gt;</code> 部分 <ol><li>对于 <code>&lt;style&gt;</code> 部分，<code>vue-loader</code> 会根据配置使用不同的样式加载器进行处理。</li><li>若使用了 <code>scoped</code> 属性（如上述示例），<code>vue-loader</code> 会对样式进行局部化处理，确保样式仅应用于当前组件，而不会影响到其他组件。</li><li>样式加载器会将 CSS 代码转换为 JavaScript 代码，并在运行时将样式注入到页面中，或根据配置提取为单独的 CSS 文件。</li></ol></li><li>提供热重载（HMR）支持 <ol><li>在开发环境中，<code>vue-loader</code> 支持热重载功能</li><li>当修改 <code>.vue</code> 文件中的代码时，<code>vue-loader</code> 可以在不刷新整个页面的情况下，仅更新相应的组件，提高开发效率</li></ol></li><li>资源 URL 处理 <ol><li><code>vue-loader</code> 可以处理在模板和样式中使用的资源 URL，如 <code>&lt;img src=&quot;@/assets/logo.png&quot;&gt;</code> 或 <code>background-image: url(&#39;@/assets/background.jpg&#39;)</code></li><li>它会将这些相对 URL 转换为最终打包后可以正确引用的 URL，确保资源可以被正确加载</li></ol></li></ol><h2 id="_4-常用的优化策略" tabindex="-1">4.常用的优化策略 <a class="header-anchor" href="#_4-常用的优化策略" aria-label="Permalink to &quot;4.常用的优化策略&quot;">​</a></h2>`,24)]))}const g=e(t,[["render",p]]);export{u as __pageData,g as default};
